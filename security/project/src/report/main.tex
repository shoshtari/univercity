\documentclass[12pt]{article}

\usepackage[a4paper, margin=0.5in]{geometry}
\usepackage{anyfontsize}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage[backend=biber]{biblatex}
\usepackage{float}
\usepackage{svg}
\usepackage{xepersian}

\hypersetup{colorlinks,urlcolor=blue}
\settextfont[Scale=1.1]{Far.Mitra}

\addbibresource{references.bib}


	\def\labelitemi{$\diamond$}% استفاده از نماد الماس
\def\labelitemii{$\ast$}% استفاده از نماد ستاره

\begin{document}
	\linespread{3}
	\setstretch{1.5}
	
	\begin{center}
		\includegraphics{logo.png}  
		\\
		~\\
		~\\
		~\\
		~\\
		
		\Large
		
		افزونه های امنیتی \lr{DNS}، همه گیری و کارایی
	\end{center}
	
	\hrule 
	
	\begin{center}
		مرتضی ملکی نژاد شوشتری \\
		۴۰۰۵۲۲۲۱۱ \\
		درس امنیت سیستم های کامپیوتری - بهار ۱۴۰۴
	\end{center}
	\normalsize
	\newpage
	\tableofcontents
	\newpage
	
	\section{چکیده}
	در سال ۱۹۸۴ میلادی که \lr{DNS} به طور رسمی معرفی شد، امنیت از دغدغه های آن نبود. به همین علت مشکلات امنیتی زیادی در این پروتکل کشف شد و برای هرکدام از آن ها راه حل هایی بیان شد.
	
	\lr{DNSSEC} این مسئله را حل میکند که کاربر بتواند تایید کند که این رکورد\footnote{\lr{record}} توسط جای معتبری تنظیم شده است و یک مهاجم این را تنظیم نکرده است.
	
	در این گزارش به شیوه کار \lr{DNSSEC}، مسائلی که حل میکند، چالش ها و گستردگی آن میپردازیم.
	
	\section{مقدمه}
	از آنجایی که \lr{DNS} بخش جدایی ناپذیری از اینترنت است، بدیهی است امنیت آن نیز جزو مهم ترین مباحث امنیت اینترنت باشد. دسته ای از حملاتی که روی \lr{DNS} رخ می‌دهد، از این نوع است که مهاجم تلاش دارد به طرق مختلف رکورد مورد نظر خود را تنظیم کند و کاربران دامنه هدف را به سمت آدرس \lr{IP} خود هدایت کند. به عنوان مثال میتوان به حمله \lr{Kaminsky} در سال ۲۰۰۸ اشاره کرد که با استفاده از \lr{Cache poisoning} فرد مهاجم به راحتی میتوانست رکورد های مورد نظر خود را تنظیم کند
	\cite{kaminsky}
	یا در سال ۲۰۱۴ نیز محققان کشف کردند که ایمیل هایی که به سمت سرورهای \lr{Gmail}، \lr{Yahoo} و ... باید میرفتند، به سمت سرورهای ایمیل ناشناسی میرفتند \cite{cmuCachePoisoning2014}
	
	برای جلوگیری از این حملات \lr{DNSSEC} ارائه شد تا با استفاده از زیرساخت های فعلی \lr{DNS} بتواند این تضمین را بدهد که این رکورد \lr{DNS} توسط سازمان یا شخص معتبری تعریف شده است.
	
	\lr{DNSSEC} نسبت به \lr{DNS} پیاده سازی پیچیده تری دارد و همین امر منجر به این شده که تمایل جامعه نسبت به به کارگیری آن کمی کم باشد. البته با توجه به مزایای امنیتی ای که دارد این رشد مثبت است ولی چالش هایی در زمینه استقرار و نظارت دارد.
	
	\section{شیوه}
	\subsection{ حملات}

	\subsubsection{حمله \lr{Kaminsky}}
	این حمله در سال ۲۰۰۸ توسط دن کامینسکی کشف شد. در این حمله:
	
	\begin{itemize}
		\item مهاجم ابتدا درخواست‌هایی برای زیردامنه‌های تصادفی از دامنه هدف (مثال: \lr{abc123.example.com}) ارسال می‌کند.
		\item همزمان با این درخواست‌ها، مهاجم تعداد زیادی پاسخ جعلی با شناسه‌های تراکنش تصادفی ارسال می‌کند.
		\item اگر یکی از این پاسخ‌ها با شناسه تراکنش واقعی مطابقت داشته باشد، سرور \lr{DNS} رکورد جعلی را می‌پذیرد.
		\item از آنجا که حمله روی دامنه اصلی (\lr{example.com}) انجام می‌شود، تمام زیردامنه‌ها تحت تأثیر قرار می‌گیرند.
	\end{itemize}
	
	این حمله به‌خصوص خطرناک است زیرا:
	\begin{itemize}
		\item نیاز به حدس زدن تنها یک شناسه تراکنش دارد
		\item اثر آن روی تمام زیردامنه‌ها اعمال می‌شود
		\item می‌تواند در مدت زمان کوتاهی انجام شود
	\end{itemize}
	
\subsubsection{حمله \lr{Cache Poisoning} سال ۲۰۱۴}
در سال ۲۰۱۴ محققان امنیتی کشف کردند که مهاجمان توانسته‌اند با استفاده از آسیب‌پذیری در سرورهای \lr{DNS}، ترافیک ایمیل‌های مربوط به سرویس‌های بزرگی مانند \lr{Gmail}، \lr{Yahoo} و دیگر ارائه‌دهندگان را به سرورهای تحت کنترل خود هدایت کنند. مشخصات این حمله شامل:

\begin{itemize}
	\item مهاجمان از آسیب‌پذیری در الگوریتم‌های تولید شناسه تراکنش \lr{DNS} سوءاستفاده کردند
	\item با مسموم کردن کش \lr{DNS}، رکوردهای \lr{MX} (مربوط به سرورهای ایمیل) را تغییر دادند
	\item این حمله منجر به انحراف ترافیک ایمیل‌های حساس به سرورهای مخرب شد
	\item مدت زمان قابل توجهی طول کشید تا این حمله کشف و رفع شود
\end{itemize}

این واقعه نشان داد که حتی زیرساخت‌های مهم اینترنتی نیز در برابر حملات \lr{DNS} آسیب‌پذیر هستند و لزوم استفاده از \lr{DNSSEC} را بیش از پیش آشکار کرد. در این حمله:
\begin{itemize}
	\item مهاجمان توانستند به مدت چندین ساعت ترافیک ایمیل را منحرف کنند
	\item امکان سرقت اطلاعات حساس مانند اعتبارنامه‌های ورود وجود داشت
	\item بسیاری از سازمان‌ها و ارائه‌دهندگان سرویس پس از این واقعه به سرعت پیاده‌سازی \lr{DNSSEC} را آغاز کردند
\end{itemize}
	
	\subsection{نحوه کار \lr{DNSSEC}}
	\lr{DNSSEC}
	با استفاده از چندین نوع رکورد جدید کار میکند. تا بتواند 
	\lr{Integrity}
	و
	\lr{Authenticity}
	را ارائه بدهد. در 
	\lr{DNSSEC}
	ما دغدغه 
	\lr{Confidentiality}
	نداریم و همچنان افراد میانی میتوانند ببینند چه رکوردی درخواست داده شده است.
	
	\lr{DNSSEC}
	از زیرساخت موجود در خود \lr{DNS} بهره میبرد و مفهوم جدیدی در لایه زیرساخت اضافه نمیکند. به همین منظور چندین نوع جدید رکورد 
	\lr{DNS}
	اضافه شده که لیست آن ها آمده.

	\subsubsection{انواع رکورد های جدید}
	\begin{itemize}
		\item 
		\lr{
		\textbf{RRset}
	}
		یک دسته از رکورد ها که همه یک نوع دارند میتوانند یک \lr{RRSet} را تشکیل بدهند.
		\item 
	\lr{
		\textbf{RRSig}
	}
محتوی امضای یک \lr{RRSet} است.
		\item 
\lr{
	\textbf{DNSKEY}
}
کلید عمومی امضا را دارد که کاربر ها با آن بتوانند صحت امضا را چک کنند.
		\item 
\lr{
	\textbf{DS}
}
هش یک رکورد \lr{DNSKEY} را دارد. برای اینکه اختیار یک دامنه به یک کلید دیگر منتقل شود استفاده می‌شود. (برای مثال \lr{Cloudflare} امکان صدور امضای رکورد های \lr{example.com} را به صاحب دامنه می‌دهد و اگر کسی کلید \lr{Cloudflare} را قبول داشته باشد می‌تواند از روی آن به صحت کلید صاحب سایت نیز برسد.)
		\item 
\lr{
	\textbf{NSEC, NSEC3}
}
برای اینکه یک امضا را نامعتبر بنامیم استفاده می‌شود.
		\item 
\lr{
	\textbf{CDS, CDNSKEY}
}
برای اینکه در یک ناحیه 
\footnote{\lr{zone}}
فرزند از ناحیه والد بخواهیم تا رکورد \lr{DS} خود را به روز کند.
	
	\end{itemize}	
	
	\subsection{امضا کردن}
	\subsubsection{
	\lr{ZSK}
	}
	هر سرور یک جفت کلید \lr{ZSK} دارد که کلید عمومی آن رکورد 
	\lr{DNSKEY}
	را میسازد و کلید خصوصی آن جهت امضا کردن 
	\lr{RRSet}
	های آن ناحیه استفاده می‌شود.
	
	هنگامی که کاربر یک رکورد \lr{DNS} را میخواهد،‌سرور \lr{RRSig} و \lr{DNSKEY} متناظر با آن را نیز میفرستد تا کاربر بتواند اصالت این رکورد را تایید کند.
	
	\begin{figure}[h]


			\includegraphics[width=0.8\textwidth]{pics/1.png}  
			\caption{
			برای تایید اصالت یک رکورد به هر سه مورد 
			\lr{RRSet}،
			\lr{DNSKEY}،
			و 
			\lr{RRSIG}
			نیاز است.
						\cite{cloudflare}
			}

				\end{figure}
				\subsubsection{\lr{KSK}}
خود رکورد 
\lr{DNSKEY}
توسط کلیدی به اسم 
\lr{KSK}
در فرایند مشابهی امضا میشود. رابطه بین 
\lr{KSK}
و
\lr{ZSK}
مشابه رابطه بین 
\lr{Refresh Token}
و
\lr{Access Token}
در 
\lr{Session Authentication }
است.

همچنان مشابه قسمت قبل،‌بخش عمومی 
\lr{KSK}
در یک رکورد 
\lr{DNSKEY}
قابل دسترس است و برای احراز اصالت امضاهای آن مورد نیاز است.

	
\begin{figure}[h]
	
	
	\includegraphics[width=0.8\textwidth]{pics/2.png}  
	\caption{
		رکورد 
		\lr{DNSKEY}
		از روی 
		\lr{KSK}
		بدست می‌آید و سپس با آن می‌شود 
		\lr{RRSet}
		های مختلفی را امضا کرد.
		\cite{cloudflare}
	}
\end{figure}


\subsubsection{
واگذاری امضا
}
اگر هر سرور بخواهد به صورت آفلاین 
\footnote{\lr{Offline}}
	کلید 
	\lr{KSK}
	خود را به کاربر برساند، مقادیر این کلید ها بسیار زیاد می‌شود. پس این راه مناسبی نیست.
	
	راه مناسب تر این است که بتوان کلید های محدودی را در دستگاه های کاربران هاردکد
	\footnote{\lr{Hardcode}}
	کرد و سپس صاحبان این کلید ها کنترل دامنه را به دست صاحبان دامنه بسپارند.
	
	این کار به این صورت انجام می‌شود که در 
	\lr{DNS Provider}
	های سطح بالا یک رکورد 
	\lr{DS}
	تنظیم می‌شود که حاوی هش 
	\lr{DNSKEY}
	برای 
	\lr{DNS Provider}
	سطح پایین تر است.
	اصالت این رکورد نیز همچون سایر رکورد ها با استفاده از 
	\lr{RRSIG}
	و 
	\lr{DNSKEY}
	مربوط به 
	\lr{DNS PROVIDER}
	سطح بالاتر قابل احراز است.
	
	از آنجایی که رکورد \lr{DS} هش رکورد \lr{DNSKEY} مربوط به \lr{KSK} سطح پایین تر را دارد، پس هر تغییری در \lr{KSK} نیاز به تغییر رکورد \lr{DS} نیز دارد. پس تغییر \lr{KSK} به نسبت تغییر هزینه بر تری است نسبت به \lr{ZSK}.
	
	\subsubsection{
	نبود رکورد و چالش های امنیتی آن
	}
	در صورتی که پاسخ
	\lr{DNS SERVER}
	خالی باشد، پیامی برای امضا نداریم، از این رو رکورد \lr{NSEC} معرفی شد.
	
	این رکورد وقتی دامنه درخواستی را نداشته باشد،‌دامنه بعدی را می‌دهد و به این ترتیب کاربر ما می‌فهمد آدرس درخواستی او وجود ندارد.
	
	البته با این رکورد یک فرد میتواند همه زیردامنه های یک دامنه را بدست بیاورد.
	
	\subsubsection{زنجیره اعتماد}
	جندین کلید ریشه در کلاینت ها هاردکد می‌شود و سایر کلید ها اعتبار خود را از این کلید ها بدست می‌آورند.
	
	اینکار با استفاده از رکورد \lr{DS} که بیان شد انجام می‌شود.
	
\begin{figure}
	
	
	\includegraphics[width=0.8\textwidth]{pics/3.png}  
	\caption{
		به صورت زنجیری هر کلید اعتبار خود را از کلید قبل می‌گیرد. به غیر از کلید ریشه.
		\cite{medium}
	}
\end{figure}


\section{چالش ها}
علیرغم این که \lr{DNSSEC} مسائل بسیاری را حل می‌کند ولی خود \lr{DNSSEC} نیز چالش های جدیدی را پدید می‌آورد. 

یک سری از این چالش ها ناشی از سربار تازه ایست که به سیستم اضافه شده

بخش بیشتر این چالش ها ناشی از پیچیدگی \lr{DNSSEC} است که خود را در نرخ همه گیری 
\footnote{\lr{Adaption}}
پایین،
\lr{Deploy}
های سخت و ... نشان می‌دهد.

\subsection{
چالش های \lr{Performance}
}
\lr{DNSSEC}
در کمترین حالت مجبور میکند تا سرور ۲ رکورد اضافه تر را پیدا کند. همچنین سایز جواب نیز زیاد شده است. علیرغم اینکه مقدار سربار اضافه شده به نوع بار سیستم وابسته است، در تحقیقی
\cite{performance}
که انجام شده، تقریبا ۴۲۵ درصد سربار پردازشی به سیستم وارد شده است که هم به علت داده بشتر و هم به علت محاسبه امضا است. از همچنین با توجه به نرخ رشد اینترنت این موضوع واضح است که لود همواره در حال بیشتر شدن است.
\begin{figure}[H]
	\includegraphics[width=0.8\textwidth]{pics/10.png}
	\caption{
	نرخ تاخیر در حالت های مختلف 
	}
\end{figure}

از طرف دیگر بخشی از راه حل های این مشکل صرفا به پخش بار پرداخته اند و ایده ای برای کم تر کردن 
سربار پردازشی ارائه نداده اند.
\subsubsection{
\lr{Prefetch}
}
یکی از راه هایی که بیان شده استفاده از معماری \lr{Prefetch} است که با استفاده از یک سیستم کش چندلایه و توزیع شده سعی در حل این موضوع دارد. \cite{prefetch}

\paragraph{راه‌حل اصلی: تقسیم‌بندی هوشمند ترافیک}
معماری \lr{PREFETCH$_X$} با دو مکانیسم اصلی کار می‌کند:

\begin{itemize}
	\item \textbf{پیش‌بارگذاری (\lr{Prefetching})}: 
	\begin{itemize}
		\item $X$ دامنه پرترافیک (\lr{HEAD$_X$}) در یک کش اختصاصی ذخیره می‌شوند
		\item این کش می‌تواند روی کارت‌های شتاب‌دهنده سخت‌افزاری شبکه (\lr{NHAC}) پیاده‌سازی شود
		\item برای $X=2000$، حدود ۶۸\% ترافیک به این روش پاسخ داده می‌شود
	\end{itemize}
	
	\item \textbf{مدیریت دامنه‌های کم‌ترافیک (\lr{TAIL$_X$})}:
	\begin{itemize}
		\item با استفاده از ساختار \lr{Distributed Hash Table}
		\item مبتنی بر پروتکل \lr{Pastry} برای توزیع یکنواخت بار پردازشی
		\item پنج مدل مختلف برای مدیریت کش ارائه شده است
	\end{itemize}
\end{itemize}

\paragraph{مزایای کلیدی معماری}
\begin{itemize}
	\item \textbf{کاهش منابع مورد نیاز}:
	\begin{itemize}
		\item تا ۴ برابر کاهش تعداد سرورها نسبت به معماری سنتی \lr{IP$_{XOR}$}
		\item کاهش ۵۵\% منابع برای \lr{DNS} معمولی و ۸۰\% برای \lr{DNSSEC}
	\end{itemize}
	
	\item \textbf{توزیع یکنواخت بار پردازشی}:
	\begin{itemize}
		\item با انتخاب $X=2000$، تغییرات بار پردازشی کمتر از ۱۰\% می‌شود
		\item توزیع یکنواخت کوئری‌ها و عملیات \lr{resolve} بین سرورها
	\end{itemize}
	
	\item \textbf{سازگاری با زیرساخت موجود}:
	\begin{itemize}
		\item نیاز به تغییرات اساسی در زیرساخت شبکه فعلی ندارد
		\item امکان پیاده‌سازی تدریجی
	\end{itemize}
\end{itemize}

\paragraph{مدل‌های مختلف مدیریت \lr{TAIL$_X$}}
مقاله پنج مدل مختلف برای مدیریت دامنه‌های کم‌ترافیک بررسی کرده است:

\begin{itemize}
	\item \lr{Pastry} (پایه): بدون مکانیسم کش‌گذاری خاص
	\item \lr{Pastry-SF} (\lr{Stateless Forwarding)}: ارسال پاسخ مستقیماً به کاربر نهایی
	\item \lr{Pastry-PC} (\lr{Passive Caching}): کش‌گذاری غیرفعال پاسخ‌ها
	\item \lr{Pastry-R} (\lr{Replication}): تکثیر پاسخ‌ها روی $k$ همسایه
	\item \lr{Pastry-AC} (\lr{Active Caching}): کش‌گذاری فعال برای دامنه‌های پرترافیک
\end{itemize}

\paragraph{نتایج تجربی و اعتبارسنجی}
\begin{itemize}
	\item پیاده‌سازی آزمایشی با \lr{FreePastry} انجام شده است
	\item همبستگی ۰.۹۹۹۱ بین مدل نظری و نتایج عملی
	\item برای $X=2000$ و ۱۸ سرور:
	\begin{itemize}
		\item کاهش ۳۰\% بار پردازشی نسبت به \lr{IP$_{XOR}$}
		\item توزیع یکنواخت ترافیک بین سرورها
	\end{itemize}
\end{itemize}

\paragraph{چالش‌ها و محدودیت‌ها}
\begin{itemize}
	\item نیاز به تحلیل ترافیک برای تعیین مقدار بهینه $X$
	\item پیچیدگی مدیریت همزمان دو لایه کش (\lr{HEAD$_X$} و \lr{TAIL$_X$})
	\item هزینه اولیه پیاده‌سازی سخت‌افزارهای شتاب‌دهنده
\end{itemize}


\subsection{چالش‌های همه‌گیری}
با وجود مزایای امنیتی قابل توجه \lr{DNSSEC}، نرخ پذیرش 
\footnote{\lr{Adaption}}
 آن در سطح جهانی همچنان پایین است. این مسئله ناشی از چندین چالش کلیدی است:

\begin{itemize}
	\item \textbf{پیچیدگی پیاده‌سازی}: فرآیند تولید، ذخیره‌سازی و مدیریت کلیدهای \lr{ZSK} و \lr{KSK}، امضای رکوردها، و نگهداری زنجیره اعتماد برای بسیاری از سازمان‌ها پیچیده و زمان‌بر است.
	\item \textbf{عدم آگاهی عمومی}: بسیاری از مدیران سیستم و توسعه‌دهندگان از نحوه عملکرد و اهمیت \lr{DNSSEC} اطلاع کافی ندارند یا تصور می‌کنند که تهدیدات مرتبط با \lr{DNS} برای آن‌ها جدی نیست.
	\item \textbf{مشکلات سازگاری}: برخی سرویس‌ها و زیرساخت‌های قدیمی با رکوردهای \lr{DNSSEC} سازگاری کامل ندارند، یا نیاز به پیکربندی‌های خاصی دارند که مانع از پذیرش آن می‌شود.
	\item \textbf{محدودیت در ابزارها و مستندسازی}: به دلیل نسبتاً جدید بودن \lr{DNSSEC}، ابزارهای مدیریتی کمتری برای آن وجود دارد و مستندسازی رسمی نیز نسبت به سایر فناوری‌ها کمتر است.
\end{itemize}

این چالش‌ها باعث شده‌اند که با وجود تهدیدات جدی علیه \lr{DNS}، بسیاری از دامنه‌ها همچنان از \lr{DNSSEC} استفاده نکنند. در آمارهایی که توسط سازمان‌های ثبت دامنه منتشر شده‌اند، مشاهده می‌شود که نرخ فعال‌سازی \lr{DNSSEC} برای دامنه‌های سطح بالا (مانند \lr{.com}، \lr{.org}) هنوز به درصد مطلوبی نرسیده است.

افزایش نرخ پذیرش \lr{DNSSEC} نیازمند تلاش مشترک شرکت‌های ثبت دامنه، ارائه‌دهندگان خدمات \lr{DNS}، توسعه‌دهندگان زیرساخت، و سازمان‌های استانداردگذاری است.

در یک تحقیق که در سال ۲۰۱۷ انجام شد
\cite{adapt}
با استفاده از گرفتن لیست \lr{zone} های ریشه از \lr{IANA} و سپس انجام
\lr{Zone enumeration}
بر روی همه 
\lr{TLD}
\footnote{\lr{Top level domain}}
ها می‌توان دید که تنها حدود ۱ درصد از دامنه ها از \lr{DNSSEC} استفاده می‌کنند. البته که این موضوع بسته به جایگاه و نوع رکورد \lr{DNS} دارد.
				\begin{figure}[H]
	\includegraphics[width=0.8\textwidth]{pics/11.png}  
	\caption{
		شیوه های یافتن دامنه های با پشتیبانی از \lr{DNSSEC}
}
\end{figure}
\begin{itemize}
	\item 
	\lr{TLD} ها:
	\lr{TLD} ها به نسبت نرخ 
	\lr{Adaption }
	خوبی دارند. در سال ۲۰۱۴ حدود یک سوم آن ها از \lr{DNSSEC} استفاده می کردند و این آمار همواره رو به رشد بوده است.
	
				\begin{figure}[H]
		\includegraphics[width=0.8\textwidth]{pics/8.png}  
		\caption{
			تعداد 
			\lr{TLD}
			ها در گذر زمان
		}
	\end{figure}
	
\end{itemize}
\subsubsection{پیچیدگی}
این مورد درواقع ریشه بسیاری از چالش های \lr{DNSSEC} است. به طوری که نرخ پذیرش پایین و یا حتی نیاز به توان پردازشی بیشتر نیز ناشی از این هستند. البته که این موضوع چندان بدیهی هم نیست زیرا \lr{DNSSEC} اولین سیستم رمزنگاری کاملا توزیع شده است و مشابه هر سیستم توزیع شده دیگری، برای غلبه بر چالش های موچود به سمت پیچیده شدن رفته است.

\paragraph{نظارت}
هرچند همچنان میتوان کارهایی کرد که درزمینه های مختلف اثر این پیچیدگی کمتر شود 

یکی از راه هایی که برای کم تر کردن اثر این مشکل پیشنهاد شده،‌استفاده از یک سیستم نظارت بر 
\lr{DNSSEC}
است که به صاحبان سرور وضعیت هم دامنه خود و هم دامنه هایی که کاربرانشان مشاهده می‌کنند  را اطلاع دهد. از جمله این سیستم ها می‌توان به 
\lr{SecSpider}
اشاره کرد.
\cite{secspider}

یکی از فایده های این سیستم آگاهی دادن به افراد است درصورتی که \lr{DNSSEC} درست \lr{Deploy} نشده باشد. جالب است که این آمار کم نیست و حدود ۰.۴۵ درصد سایت هایی که \lr{DNSSEC} را فعال کرده بودند، درست نبودند.

ابزاری مثل \lr{secspider} باید سایت های با پشتیبانی از \lr{DNSSEC} را از جاهای مختلف رصد کند زیرا ممکن است در یک جا امضا سالم به شمار بیاید و در جایی دیگر خیر.

\paragraph{سیستم رمزنگاری}
در پاسخ به پیچیدگی و همچنین 
\lr{Resource intensive}
بودن فرآیند \lr{DNSSEC} پیشنهادی که مطرح شد این است که به جای استفاده از رمزنگاری پیش‌فرص 
\lr{RSA}
از رمزنگاری های مبتنی بر خم های بیضوی
\footnote{\lr{Elliptic Curve}}
استفاده شود. 
\cite{ecc}

این کار چندین فایده مهم دارد:
\begin{itemize}
	\item 
	\textbf{
	کاهش احتمال 
	\lr{IP Fragmentaion}
	}
	کلید  های \lr{ECC} در مقایسه با \lr{RSA} سایز کوچکتری دارند و این امر منجر به این می‌شود که احتمال 
	\lr{IP Fragmentaion}
	کمتر بشود.
	
		\begin{figure}[h]
		
		
		\includegraphics[width=0.8\textwidth]{pics/4.png}  
		\caption{
			در اینجا واضح است که اگر از 
			\lr{RSA}
			استفاده شود. روی 
			\lr{Ethernet}
			درصدی از دامنه ها
			و روی 
			\lr{IPV6}
			تقریبا همه دامنه ها سایز جواب از 
			\lr{MTU}
			بیشتر می‌شود و 
			\lr{Fragmentation}
			رخ می‌دهد ولی اگر از رمزنگاری های مبتنی بر 
			\lr{ECC}
			استفاده شود، می‌توان دید که سایز جواب بسیار کمتر است و احتمال 
			\lr{Fragmentation}
			کمتر است.
		}
		
	\end{figure}
	\item
	\textbf{
	کاهش ریسک 
	\lr{Amplification Attack}
	}
	همانطور که بیان شد،‌
	\lr{DNSSEC}
	باعث افزایش لود سیستم می‌شود و از این رو هدف حمله های از نوع 
	\lr{DDoS}
	\footnote{
	\lr{Distributed Denial of Service}
	}
	است. 
	
	یکی از معروف ترین نوع این حملات حملات تشدیدی
	\footnote{
	\lr{Amplification Attack}
	}
	است. از آنجایی که در \lr{DNSSEC} برای دریافت یک رکورد به مراتب کارهای بیشتری انجام می‌شود پس نسبت به 
	\lr{DNS}
	معمولی به این حمله آسیب پذیر تر است. ولی از آنجایی که \lr{ECC} به علت سایز کلید کوچک تر، به طور خاص در رمزگشایی رمزنگاری سبک تری است، انتظار می‌رود که اثر کمتری بپذیرد.
	
	طی تحقیقی که انجام شد، این کار می‌تواند بین ۴۰ تا ۵۰ درصد اثر حملات تشدیدی را کاهش دهد.
	\begin{figure}[H]
	\includegraphics[width=0.8\textwidth]{pics/5.png}  
	\caption{
		می‌توان دید که در
		\lr{ECC}
		میزان ضریب تشدید از حالت معمول بسیار کمتر است.
		\\
		همچنین می‌توان دید که با این حال 
		\lr{DNS}
		معمولی از همه ضریب کمتری دارد.
	}
\end{figure}

\item 
\textbf{سرعت}
از آنجایی که 
\lr{ECC}
سرعت رمزگشایی از 
\lr{RSA}
کمتر است، این مورد یک چالش است. 

رمزنگاری های مختلف
\lr{ECC}
می‌توانند تا چندین برابر کند تر از 
\lr{RSA}
باشد.
		\begin{figure}[H]
		\includegraphics[width=0.8\textwidth]{pics/6.png}  
		\caption{
		هر خانه می گوید رمزنگاری متناظر 
		\lr{ECC}
		چند برابر رمزنگاری متناظر \lr{RSA} دور کلاک نیاز دارد.
		}
	\end{figure}
	
	\item \textbf{حجم}
	به طور کلی حجم مرسوم رکورد های \lr{DNS}  حداکثر ۵۱۲ بایت بوده (این در \lr{RFC} نیامده ولی به طور مرسوم اینقدر بوده است.) 
	
	از آنجایی که حجم \lr{ECC} کمتر است میتوان انتظار داشت ردپای کمتری روی حجم جواب ها به نسبت 
	\lr{RSA}
	داشته باشد که همین طور هم است.
			\begin{figure}[H]
		\includegraphics[width=0.8\textwidth]{pics/7.png}  
		\caption{
میتوان دید که اکثر جواب ها زیر 
۵۱۲
\lr{byte}
فضا اشغال می‌کنند.
		}
	\end{figure}
	
	\item 
	\lr{Adaption}
	طی تحقیقی که در سال ۲۰۱۷ انجام شد، اکثریت دامنه ها همچنان از \lr{RSA} استفاده می‌کنند و درصد کمی از آن ها از \lr{ECDSA} استفاده می‌کنند.
	
				\begin{figure}[H]
		\includegraphics[width=0.8\textwidth]{pics/9.png}  
		\caption{
		میزان استفاده از الگوریتم های رمزنگاری در 
		\lr{Second level domain}
		ها
		(ژانویه ۲۰۱۷)
	}  
	\end{figure}
	
\end{itemize}

\subsubsection{
\lr{Zone enumeration}
}
همانطور که بیان شد وجود رکورد های 
\lr{NSEC}
به فرد این امکان را می‌دهد تا همه دامنه های یک 
\lr{zone}
را دربیاورد. 

البته اگر از 
\lr{NSEC3}
استفاده شود به علت اینکه از هش دامنه استفاده می‌کند این کار سخت تر می‌شود. ولی در تحقیقی که برای یافتن همه گیری 
\lr{DNSSEC}
انجام شده
\cite{adapt}
، با استفاده از ۷ عدد \lr{GPU} و شیوه 
\lr{Brute force}
حدود ۷۸ درصد هش های رکورد های 
\lr{NSEC3}
ظرف ۲ هفته شکسته شده اند.

البته در همین تحقیق شکستن هشت رکورد \lr{NSEC3} دو مورد از 
\lr{TLD}
ها با شکست مواجه شد. یک مورد به علت خطای تنظیم \lr{NSEC} از سوی \lr{TLD} بوده ولی مورد دیگر دربار \lr{TLD} مربوط به \lr{py} بوده که \lr{salt} هش را هر ده دقیقه یکبار عوض میکرده و شکستن هش را سخت و عملا غیر ممکن می‌سازد.

\paragraph{\lr{NSEC5}}
برای حل مشکل 
\lr{Zone Enumeration}
یکی از راه حل هایی که برای این مشکل مطرح شد،‌ایده \lr{NSEC5} بود
\cite{nsec5}
.
 اساس این ایده بر این پایه است که مشکل \lr{NSEC3} استفاده از الگوریتم های هش بدون کلید است و اگر از یک هش با کلید استفاده کنیم،‌(عملا امضا را به جای هش محاسبه کنیم) از آنجایی که فقط سرور قابلیت ایجاد هش را دارد ولی همه کاربر ها قابلیت تایید هش را دارند و می‌توانند ببینند هش گرفته شده از سرور آیا مربوط به دامنه مدنظرشان است یا خیر.
 
 این ایده با اینکه در ژورنال معروفی چاپ نشده ولی نسخه پیش چاپ آن در آرشیو \lr{iacr} 
  \footnote{\lr{https://eprint.iacr.org}}
 بیش از ۸۰ مرتبه ارجاع خورده است.


	
	\section{جمع‌بندی}
	مسائلی که 
	\lr{DNSSEC}
	قصد دارد آن ها را حل کند، مسائل درستی هستند ولی به علت پیچیدگی بیش از حد این افزونه و اثر آن در 
	\lr{Performance}
	و راحتی استقرار باعث شده که اقبال عمومی به سمت آن کم باشد. کما اینکه در 
	\lr{TLD}
	ها که کار اصلی آن ها این است میبینیم 
	\lr{DNSSEC}
	توانسته 
	\lr{Adaption}
	خوبی داشته باشد. 
	
	مهم ترین جایی که \lr{DNSSEC} نتوانسته به نرخ پذیرش خوبی برسد، در ‌\lr{SLD} 
	\footnote{\lr{Second level domain}}
	ها است. هرچند با توجه به اینکه برای چالش های مختلف آن مثل مانیتورینگ‌،‌
	\lr{Performance}
	،
	حجم درخواست ها،‌
	\lr{Fragmentaion}
	و ... راه حل هایی ارائه شده. به نظر می‌آید که مشکل جدی ای برای 
	\lr{DNSSEC}
	نباشد و با رفع این مشکلات بتواند 
	\lr{Adaption}
	بالایی داشته باشد.
	
	
	
	\newpage
	\section{مراجع}
	\begin{latin}
		
		
		\printbibliography[title={مراجع},heading=none]
	\end{latin}
	
\end{document}